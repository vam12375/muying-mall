# 母婴商城技术栈详解

## 技术选型概述

母婴商城系统在技术选型上遵循"稳定可靠、高效扩展、开发友好"的原则，采用了业界成熟且具有良好生态的技术栈。本文档详细介绍各层次使用的技术及选型理由。

## 核心框架与环境

### Spring Boot 3.2.0

**选型理由**：
- **开发效率**：自动配置和约定优于配置原则大幅提升开发效率
- **生态系统**：拥有庞大的扩展库和活跃的社区支持
- **版本先进性**：3.2.0版本包含多项性能改进和新特性
- **企业支持**：由Spring团队长期维护，稳定可靠

**核心功能**：
- Spring MVC：处理Web请求，RESTful API设计
- Spring IoC：管理组件依赖
- Spring AOP：处理横切关注点
- Actuator：提供系统监控和指标收集
- DevTools：提升开发效率

### Java 21

**选型理由**：
- **长期支持**：作为LTS版本，提供长期的安全更新和支持
- **性能提升**：较之前版本有显著性能提升
- **新特性**：虚拟线程、增强型switch表达式、记录类等
- **稳定性**：经过充分测试的生产版本

**核心特性**：
- 虚拟线程：提高并发处理能力，降低资源消耗
- 记录类：简化数据传输对象的创建和管理
- 模式匹配：使代码更简洁易读
- 文本块：改善SQL和JSON等多行字符串的处理

## 数据层技术

### MyBatis-Plus 3.5.9

**选型理由**：
- **简化开发**：通用CRUD操作无需手写，提高开发效率
- **性能优异**：经过大量项目验证的优秀性能
- **功能完善**：内置分页、逻辑删除、自动填充等实用功能
- **灵活性**：兼具MyBatis的灵活性和JPA的便捷性

**核心功能**：
- 通用Mapper：自动生成基础CRUD方法
- Lambda查询：类型安全的查询构建
- 分页插件：简化分页查询实现
- 乐观锁：实现并发控制
- 逻辑删除：实现数据软删除
- 字段填充：自动处理创建时间、更新时间等

### MySQL 8.0+

**选型理由**：
- **稳定性**：经过验证的企业级数据库
- **功能完善**：支持事务、存储过程、触发器等高级特性
- **性能优化**：8.0版本在性能和安全性方面有显著提升
- **生态支持**：各种工具和框架对MySQL支持完善

**核心特性**：
- InnoDB引擎：支持事务和外键约束
- JSON支持：原生支持JSON数据类型
- 全文索引：支持复杂文本搜索
- 窗口函数：支持高级分析查询
- 事务隔离：支持多种事务隔离级别

## 缓存与会话管理

### Redis

**选型理由**：
- **性能卓越**：高性能的内存数据库
- **丰富数据结构**：支持字符串、哈希、列表、集合等多种数据结构
- **持久化**：支持RDB和AOF两种持久化方式
- **集群支持**：支持高可用集群部署

**应用场景**：
- 会话存储：存储用户会话信息
- 数据缓存：缓存热点数据，减轻数据库压力
- 分布式锁：实现高并发环境下的资源锁定
- 消息队列：实现轻量级消息传递
- 排行榜：利用Sorted Set实现实时排行榜

### Spring Session

**选型理由**：
- **分布式会话**：解决集群环境下会话共享问题
- **无缝集成**：与Spring Boot无缝集成
- **安全特性**：提供会话安全保障机制
- **灵活存储**：支持多种后端存储方案

**核心功能**：
- 分布式会话管理
- 多种会话存储选择
- 会话过期控制
- 会话事件监听

## 安全框架

### Spring Security

**选型理由**：
- **全面安全**：提供全面的安全防护
- **灵活定制**：高度可定制的安全策略
- **社区活跃**：持续更新和问题修复
- **无缝集成**：与Spring Boot生态紧密集成

**核心功能**：
- 认证管理：用户身份验证
- 授权控制：基于角色和权限的访问控制
- 密码加密：BCrypt等多种加密算法
- 防护机制：CSRF、XSS等安全防护
- OAuth2支持：支持第三方认证

### JWT (JJWT 0.11.5)

**选型理由**：
- **无状态认证**：适合分布式系统
- **减轻服务器负担**：无需服务端存储会话状态
- **跨域支持**：便于实现跨域认证
- **安全性**：支持签名验证确保数据完整性

**核心功能**：
- Token生成与验证
- 过期策略管理
- 刷新Token机制
- 签名算法选择

## API文档

### SpringDoc OpenAPI 2.2.0

**选型理由**：
- **自动生成**：根据代码自动生成API文档
- **标准支持**：符合OpenAPI规范
- **可视化界面**：内置Swagger UI提供交互式文档
- **易于维护**：文档与代码同步更新

**核心功能**：
- API接口文档自动生成
- 请求/响应模型展示
- API分组管理
- 文档版本控制
- 安全配置集成

## 搜索引擎

### Elasticsearch 8.11.0

**选型理由**：
- **全文搜索**：强大的全文检索能力
- **分布式架构**：支持水平扩展
- **实时索引**：近实时搜索能力
- **分析能力**：强大的数据分析功能

**核心功能**：
- 商品搜索：实现多条件、多字段商品搜索
- 搜索建议：实现搜索推荐功能
- 分面搜索：支持按分类、品牌等条件筛选
- 相关性排序：智能排序搜索结果
- 高亮显示：突出显示匹配关键词

## JSON处理

### FastJSON2 2.0.40

**选型理由**：
- **高性能**：卓越的JSON序列化和反序列化性能
- **功能完善**：支持复杂对象和集合类型
- **定制能力**：高度可定制的序列化规则
- **国内广泛使用**：在国内有广泛的应用和支持

**核心功能**：
- 对象序列化/反序列化
- 自定义序列化器
- 支持JSONPath
- 循环引用处理

### Jackson

**选型理由**：
- **Spring标准**：Spring Boot默认JSON处理库
- **完善的功能**：全面的功能支持
- **模块化设计**：可按需引入功能模块
- **JSR-310支持**：良好支持Java 8日期时间API

**核心功能**：
- Java 8日期处理
- 多种数据格式支持
- 注解驱动的序列化控制
- 异构类型处理

## 支付集成

### 支付宝SDK 4.38.0

**选型理由**：
- **官方支持**：支付宝官方维护和支持
- **功能完善**：覆盖支付宝全部API
- **稳定可靠**：经过大量实际应用验证
- **文档完善**：详细的集成文档和示例

**核心功能**：
- 支付接口集成
- 退款功能
- 订单查询
- 异步通知处理
- 签名验证

### 微信支付SDK 0.0.3

**选型理由**：
- **功能覆盖**：支持微信支付主要功能
- **易于集成**：简化的API调用方式
- **社区支持**：活跃的用户社区
- **轻量级**：依赖少，集成简单

**核心功能**：
- 扫码支付
- JSAPI支付
- H5支付
- 小程序支付
- 退款和查询

## 业务逻辑实现

### 状态机模式

**选型理由**：
- **业务清晰**：使复杂状态流转逻辑清晰化
- **可维护性**：状态和转换规则显式定义，易于维护
- **扩展性**：新增状态和转换规则简单
- **减少复杂条件判断**：避免复杂的if-else嵌套

**应用场景**：
- 订单状态管理
- 支付流程控制
- 退款状态跟踪
- 物流状态监控

### 事件系统

**选型理由**：
- **解耦设计**：事件发布者和订阅者解耦
- **扩展性**：方便添加新的事件处理逻辑
- **异步处理**：支持异步事件处理
- **集成简单**：与Spring Event集成简便

**应用场景**：
- 订单创建/更新通知
- 库存变动处理
- 支付状态变更
- 系统集成点

## 性能优化与监控

### Micrometer

**选型理由**：
- **统一抽象**：提供度量指标的统一抽象层
- **多系统集成**：支持多种监控系统集成
- **低侵入性**：对业务代码侵入小
- **Spring集成**：与Spring Boot无缝集成

**核心功能**：
- 性能指标收集
- 自定义监控指标
- 多种后端系统支持
- 警报阈值配置

## 架构决策记录

### 1. 选择MyBatis-Plus而非JPA

**决策**：采用MyBatis-Plus作为ORM框架，而非JPA/Hibernate。

**原因**：
- SQL直接可见，便于优化
- 在处理复杂查询时性能更优
- 学习曲线更平缓，团队更熟悉
- 提供了大量便捷功能同时保留灵活性

**权衡**：
- 失去了JPA提供的完全面向对象的持久化
- 需要更多手动映射
- 跨数据库支持不如JPA

### 2. 采用JWT替代Session-Cookie认证

**决策**：使用JWT实现认证，配合Redis黑名单机制。

**原因**：
- 有利于构建无状态服务，便于水平扩展
- 减少数据库查询，提高性能
- 适合前后端分离架构
- 便于跨域和跨服务认证

**权衡**：
- Token无法即时失效，需要配合Redis实现黑名单
- Token大小略大于会话ID
- 需要客户端存储和发送Token

### 3. 使用Redis实现分布式锁而非专用锁服务

**决策**：使用Redis实现分布式锁，而非引入ZooKeeper等专用服务。

**原因**：
- 系统已引入Redis，无需增加新组件
- 性能表现更好，适合高频锁操作
- 实现简单，维护成本低
- 适合大多数业务场景的锁需求

**权衡**：
- 在网络分区等场景下可靠性不如ZooKeeper
- 需要额外处理锁超时和续期问题

### 4. 状态机模式管理订单流程

**决策**：采用状态机模式管理订单状态流转。

**原因**：
- 订单状态流转复杂，状态机使逻辑清晰
- 便于维护和扩展，新增状态和转换简单
- 避免分散在代码各处的状态判断逻辑
- 有利于统一状态变更的前置和后置处理

**权衡**：
- 引入额外的抽象层和复杂度
- 需要团队熟悉状态机概念
- 初始设计需要更多精力 